"""This module subclasses MainFrame from the GUI_mainframe module.  It
implements all GUI-related actions and validations, as well as
instantiates the dialogs and call the wxWidgets event loop.

"""

import threading
import Queue
import wx
import time
import math
import tempfile
import subprocess
import os
import os.path
import sys
import traceback
import wx.lib.imagebrowser as imagebrowser
from PIL import Image

from gui_base import MainFrameBase
import shape
from display_wx import PaintDisplay
import config_wx
import config
from renderer import Renderer
import geometry
import bitmap
import pdf
import undo
import exporters
import printing
import myapp
import constants
import version
from gui_utils import eraseBackground

PAPER_SIZES_MM = {
            # http://en.wikipedia.org/wiki/A4_paper#A_series
            "a3": (297, 420),
            "a4": (210, 297),
            "a5": (148, 210),
            # http://en.wikipedia.org/wiki/Letter_%28paper_size%29
            "letter": (216, 279),
            "a3 landscape": (420, 297),
            "a4 landscape": (297, 210),
            "a5 landscape": (210, 148),
            "letter landscape": (279, 216),
            }

HINT_SEP = " "*4 + "/" + " "*4
HINT_SEP = " " * 6


class MainFrame(MainFrameBase):
    """This class overrides the main frame originally generated by wxGlade"""

    def __init__(self, filename, defaults, scene):
        super(MainFrame, self).__init__(None, -1, "")
        self.is_ready = False

        self.bg_bmp = wx.Bitmap("bg_1.jpg")
        self.bg_bmp_inner = wx.Bitmap("bg_2.jpg")
        self.bg_bmp_render = wx.Bitmap("bg_2.jpg")

        # this fixes weird BG color on Windows
        if os.name == "nt":
            self.SetBackgroundColour(wx.Colour(225, 225, 225))

        # restore config
        self._config = config_wx.Config()
        conf = self._config
        load_from = filename or self._config.last_saved
        values = config.load(load_from)
        if filename is not None and values:
            self._config.last_saved = filename
            self._config.save()
        if not values:
            self._config.last_saved = None
            self._config.save()

        # undo/redo
        self.undo = undo.Undo()
        self.setUndoMenu()

        # restore main frame
        if conf.checkGeometry():
            self.SetPosition((conf.pos_x, conf.pos_y))
            self.SetSize((conf.pos_w, conf.pos_h))

        # key events
        self.recursivelySetKeyEvent(self)
        self.window_anamorphosis.SetFocus()

        # mouse support
        self.window_perspective.Bind(wx.EVT_LEFT_DOWN, self.OnMouseClick)
        self.window_perspective.Bind(wx.EVT_LEFT_UP, self.OnMouseRelease)
        self.window_perspective.Bind(wx.EVT_MOTION, self.OnMouseMove)
        self.window_perspective.Bind(wx.EVT_MOUSEWHEEL, self.OnMouseWheel)
        self.click_pos = None

        self.defaults = defaults

        # camera and scene, and values
        self.scene = scene
        self.applyValues(values)

        # bind events
        self.Bind(wx.EVT_CLOSE, self.OnCloseFrame)
        self.window_perspective.Bind(wx.EVT_PAINT, self.OnPaintPersp)
        self.window_perspective.Bind(wx.EVT_SIZE, self.OnSizePersp)
        self.window_anamorphosis.Bind(wx.EVT_PAINT, self.OnPaintAnam)
        self.window_anamorphosis.Bind(wx.EVT_SIZE, self.OnSizeAnam)

        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBackground)
        if constants.IS_LINUX:
            self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)
        if constants.WITH_TEXTURE_BG:
            self.bindBg2(self.sizer_11_staticbox)
            self.bindBg2(self.sizer_112_staticbox)
            self.bindBg2(self.sizer_113_staticbox)
            self.bindBg2(self.sizer_11_copy_staticbox)
            self.bindBg2(self.sizer_2_copy_staticbox)
            self.bindBg2(self.sizer_2_staticbox)
            self.bindBg2(self.sizer_2_copy_1_staticbox)
            self.bindBg2(self.label_hint)

        # misc
        self.ctrl_pressed = False
        self.shift_pressed = False
        self.updateHint()
        self.renderer = None

        self.frames_p = 0
        self.frames_a = 0
        self.queue = Queue.Queue()
        # start the thread for deferred anamorphosis redraw
        myapp.RequestRedrawThread(self.queue,
                                  self.redrawAnamorphosisNow).start()

    def setReady(self):
        self.is_ready = True

    def bindBg2(self, box):
        box.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBackground2)

    def OnEraseBackground(self, evt):
        eraseBackground(self, evt.GetDC(), self.bg_bmp)

    def OnEraseBackground2(self, evt):
        eraseBackground(self, evt.GetDC(), self.bg_bmp_inner)
        
    #
    # State helpers
    #

    def handleChanges(self, dirty=True):
        if not dirty:
            self.undo.fixup(lambda x: [True, x[1]])
        self.dirty = dirty
        item = [self.dirty, self.values]
        self.undo.add(item)
        self.updateState()

    def updateState(self):
        self.setTitle()
        self.setUndoMenu()
        self.refresh()

    #
    # Controls & values helpers
    #

    def applyValues(self, values):
        self.title = None

        # populate controls
        self.values = values
        self.refreshControls()

        dlg = wx.ProgressDialog("Working...", "Loading images...",
                                parent=self,
                                style=wx.PD_APP_MODAL | wx.PD_SMOOTH)
        dlg.Destroy()
        self.handleChanges(dirty=False)

    def getValue(self, name):
        default = self.defaults[name]
        val = self.values.get(name, default)
        if val in (None, ""):
            val = default
        #print name, default, "->", val
        return val

    def setValue(self, name, value):
        if name in self.values and self.values[name] == value:
            return
        self.values[name] = value
        self.handleChanges()

    def setNumVal(self, name, val):
        ctrl = eval("self.spin_ctrl_%s" % name)
        val = min(val, ctrl.GetMax())
        val = max(val, ctrl.GetMin())
        ctrl.SetValue(val)
        self.setValue(name, val)

    def setNumFromSpin(self, name):
        val = eval("self.spin_ctrl_%s.GetValue()" % name)
        self.setNumVal(name, val)

    def initNum(self, name):
        val = self.values.get(name, self.defaults[name])
        self.setNumVal(name, val)

    def refreshControls(self):
        self.initNum("camera_azimuth")
        self.initNum("camera_altitude")
        self.initNum("camera_distance")
        self.initNum("camera_fov")

        self.initNum("cone_radius")
        self.initNum("cone_height")
        self.initNum("plane_tilt")

        self.initNum("export_bitmap_width")
        self.initNum("export_bitmap_height")

    def endEdits(self):
        # call me upon menu/hotkey actions, to exit focus from any
        # input widgets, so as to finish any editing session and
        # update value prior said action
        self.window_perspective.SetFocus()
        wx.Yield()

    #
    # GUI helpers
    #

    def setTitle(self):
        filename = self._config.last_saved
        if filename:
            d, name = os.path.split(filename)
        else:
            name = "no name"

        title = "*" if self.dirty else ""
        title += "%s - ConeDevelopment" % name
        if title != self.title:
            self.title = title
            self.SetTitle(title)

    def recursivelySetKeyEvent(self, what):
        for c in what.GetChildren():
            self.recursivelySetKeyEvent(c)
        what.Bind(wx.EVT_KEY_DOWN, self.OnKeyDown)
        what.Bind(wx.EVT_KEY_UP, self.OnKeyUp)

    def updateHint(self):
        if self.shift_pressed and self.ctrl_pressed:
            texts = [
                "[Ctr+shift pressed]",
                "Drag: Camera angles",
                "Wheel: Cone height",
            ]
        elif self.shift_pressed:
            texts = [
                "[Shift pressed]",
                "Drag: Camera angles (locked along axes)",
                "Wheel: Plane tilt",
            ]
        elif self.ctrl_pressed:
            texts = [
                "[Ctrl pressed]",
                "Drag: Camera angle",
                "Wheel: Cone radius",
            ]
        else:
            texts = [
                "Camera angles: drag (shift to lock)",
                "Camera distance: wheel",
                "Plane tilt: shift-wheel",
                "Cone radius: ctrl-wheel",
            ]
        self.label_hint.SetLabel(HINT_SEP.join(texts))

    def setUndoMenu(self):
        self.menu_undo.Enable(self.undo.canUndo())
        self.menu_redo.Enable(self.undo.canRedo())

    def setMarqueeImage(self, path):
        self.values["marquee_image"] = path
        self.text_ctrl_marquee_image.SetValue(path)
        self.values["marquee_show"] = True
        self.checkbox_marquee_show.SetValue(True)
        self.loadMarquee()
        self.handleChanges()

    #
    # Canvas & rendering helpers
    #

    def refresh(self):
        self.redraw(None)

    def redraw(self, arg):
        self.window_perspective.Refresh()

    def render(self, canvas):
        # create display to draw 3D scene into
        pdc = wx.PaintDC(canvas)  # simple device context
        dc = wx.GCDC(pdc)  # device context with alpha and anti-alias
        if constants.WITH_TEXTURE_CANVAS:
            eraseBackground(canvas, dc, self.bg_bmp_render)
        w, h = canvas.GetClientSize()
        display = PaintDisplay(dc, w, h)
        display.setScale(15, 15)

        # draw 3D scene
        self.scene.render(display,
                          self.getValue,
                          self.label_camera_pos.SetLabel)

        # draw 2D anamorphosis
        self.renderer = Renderer( None)


        self.frames_p += 1
        #print "P frames:", self.frames_p
        self.redrawAnamorphosis()

    def redrawAnamorphosis(self):
        if False: # <<< set True if you have a slow computer
            # time-consuming -> schedule to be redrawn when quiet
            self.queue.put(True)
        else:
            # only gridline -> refresh in real-time
            self.redrawAnamorphosisNow()

    def redrawAnamorphosisNow(self):
        self.window_anamorphosis.Refresh()

    #
    # Lifetime helpers
    #

    def closeNow(self):
        self.queue.put(None)

        # store config
        # - main frame
        pos = self.GetPosition()
        self._config.pos_x = pos[0]
        self._config.pos_y = pos[1]

        size = self.GetSize()
        self._config.pos_w = size[0]
        self._config.pos_h = size[1]

        self._config.save()

        # close WX stuff
        self.Destroy()

    #
    # Data helpers
    #
    def getCardFormat(self):
        cw = self.getValue("cone_radius")
        ch = self.getValue("cone_height")
        dim = (cw, ch)
        # TODO: if dim is in inches, convert and round to mm
        name = None
        for k, v in PAPER_SIZES_MM.items():
            if v == dim:
                name = k.lower()
                break
        return name, dim

    def makePageParams(self):
        self.setNumFromSpin("export_bitmap_height")
        cw = self.getValue("cone_radius")
        ch = self.getValue("cone_height")
        bmh = self.getValue("export_bitmap_height")
        bmw = (bmh * cw) / ch
        self.setNumVal("export_bitmap_width", bmw)

        name, paper_dim_mm = self.getCardFormat()
        w_mm, h_mm = paper_dim_mm

        dpi = 100
        if name:
            name, orientation = (name + " x").lower().split()[:2]
            is_landscape = orientation == "landscape"

            w, h = pdf.getBitmapSize(name, dpi, is_landscape)
        else:
            f = 0.0393701
            w_inch, h_inch = w_mm * f, h_mm * f
            i2d = lambda x: int(x * dpi + 0.5)
            w, h = i2d(w_inch), i2d(h_inch)

        return w, h, w_mm, h_mm

    #
    # File & project helpers
    #

    def saveAs(self):
        path = self._config.last_saved
        if path is not None:
            d, f = os.path.split(path)
        else:
            d, f = "", ""
        saveFileDialog = wx.FileDialog(self, "Save Project", d, f,
                                       "*" + constants.EXTENSION,
                                       wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT)
        resp = saveFileDialog.ShowModal()
        if resp == wx.ID_CANCEL:
            saved = False
        else:
            filename = saveFileDialog.GetPath()
            filename = myapp.fixPath(filename, constants.EXTENSION)
            self._config.last_saved = filename
            self.save()

            saved = True
        saveFileDialog.Destroy()
        return saved

    def save(self):
        if self._config.last_saved is None:
            return self.saveAs()
        else:
            config.save(self._config.last_saved, self.values)
            self.undo.undo()  # unstack last change
            self.handleChanges(dirty=False)  # will stack current values
            return True

    def saveIfNeeded(self, text):
        if self.dirty:
            askSaveAlways = False
            askSave = askSaveAlways or self._config.last_saved is None
            if askSave:
                flags = wx.YES_NO | wx.CANCEL | wx.CENTRE | wx.ICON_QUESTION
                ok = wx.MessageBox(text, _("Unsaved changes"), flags)
            if not askSave or ok == wx.YES:
                if not self.save():
                    return False
                else:
                    return True
            elif ok == wx.CANCEL:
                return False
            elif ok == wx.NO:
                return True
        return True

    def openFile(self, filename):
        if not self.saveIfNeeded(
            _("Save project before opening %s?" % filename)):
            return
        self.loadFile(filename)

    def new(self):
        if not self.saveIfNeeded(_("Save project before creating new one?")):
            return
        self.values = {}
        self._config.last_saved = None
        self.refreshControls()
        self.dirty = False
        self.setTitle()

    def printProject(self):
        img_w, img_h, pdf_w_mm, pdf_h_mm = self.makePageParams()

        dlg = wx.ProgressDialog("Working...", "Generating PDF for printing...",
                                parent=self,
                                style=wx.PD_APP_MODAL | wx.PD_SMOOTH)

        def update_fn(msg):
            dlg.Pulse(msg)
            wx.Yield()

        def done_fn(msg):
            dlg.Destroy()
            wx.Yield()

        printing.printPdf(self.renderer.renderImage, update_fn, done_fn,
                          img_w, img_h, pdf_w_mm, pdf_h_mm)

    def loadFile(self, filename):
        values = config.load(filename)
        if values:
            self.values = values
            self._config.last_saved = filename
            self.applyValues(values)
            return True
        else:
            return False

    def dropFiles(self, paths):
        f = paths[0]
        if f.lower().endswith(constants.EXTENSION):
            # project file
            if not self.saveIfNeeded(_("Save project before opening %s?" % f)):
                return
            if self.loadFile(f):
                return
        else:
            # try image file
            try:
                Image.open(f)
            except:
                dlg = wx.MessageDialog(self, _("Unrecognized file format."),
                                       _("Error"), wx.OK | wx.ICON_INFORMATION)
                dlg.ShowModal()
                dlg.Destroy()
                return
            self.setMarqueeImage(f)
            return

    #
    # Manually bound handlers
    #

    def OnCloseFrame(self, event):
        if not self.saveIfNeeded(_("Save project before closing?")):
            return
        self.closeNow()

    def OnKeyUp(self, event):
        self.OnKey(event, False)

    def OnKeyDown(self, event):
        self.OnKey(event, True)

    def OnKey(self, event, pressed):
        code = event.GetKeyCode()
        if code == wx.WXK_SHIFT:
            self.shift_pressed = pressed
            self.updateHint()
        elif code == wx.WXK_CONTROL:
            self.ctrl_pressed = pressed
            self.updateHint()
        event.Skip()

    def OnMouseClick(self, event):
        self.click_pos = event.GetX(), event.GetY()
        self.click_azimuth = self.getValue("camera_azimuth")
        self.click_altitude = self.getValue("camera_altitude")
        self.click_ctrl = event.ControlDown()

    def OnMouseRelease(self, event):
        self.click_pos = None
        self.handleChanges()

    def OnMouseMove(self, event):
        if self.click_pos is None:
            return
        # determine drag size
        dx = -event.GetX() + self.click_pos[0]
        dy = +event.GetY() - self.click_pos[1]
        if event.ShiftDown():
            # lock one direction
            if abs(dx) > abs(dy):
                dy = 0
            else:
                dx = 0
        w, h = self.window_perspective.GetClientSize()

        self.undo.enable(False)

        if True:
            # move card
            daz = (dx * 360) / w
            dal = (dy * 90) / h
            az = self.click_azimuth + daz
            ###az = max(min(az, 180), 0)
            az = az % 360
            al = self.click_altitude + dal
            self.setNumVal("camera_azimuth", az)
            self.setNumVal("camera_altitude", al)

        self.undo.enable(True)
        self.handleChanges()
        #self.updateState()

    def OnMouseWheel(self, event):
        if event.WheelRotation > 0:
            direction = -1
        else:
            direction = 1
            
        if event.ShiftDown() and event.ControlDown():
            height = self.getValue("cone_height")
            self.setNumVal("cone_height", height + direction * 5)            
        elif event.ShiftDown():
            angle = self.getValue("plane_tilt")
            self.setNumVal("plane_tilt", angle + direction * 5)
        elif event.ControlDown():
            dist = self.getValue("cone_radius")
            self.setNumVal("cone_radius", dist + direction * 5)
        else:
            dist = self.getValue("camera_distance")
            dist += dist / 10 * direction
            self.setNumVal("camera_distance", dist)

    def OnPaintPersp(self, event):
        canvas = self.window_perspective
        self.render(canvas)

    def OnSizePersp(self, event):
        canvas = self.window_perspective
        canvas.Refresh()

    def OnPaintAnam(self, event):
        canvas = self.window_anamorphosis
        if self.renderer is not None:
            self.renderer.renderCanvas(canvas)
            self.frames_a += 1

    def OnSizeAnam(self, event):
        #canvas = self.window_anamorphosis
        #wx.PaintDC(canvas).Clear()
        self.queue.put(True)

    #
    # Handler bound by wxglade
    #

    def OnCameraAltitudeSpin(self, event):
        self.setNumFromSpin("camera_altitude")

    def OnCameraAzimuthSpin(self, event):
        self.setNumFromSpin("camera_azimuth")

    def OnCameraDistanceSpin(self, event):
        self.setNumFromSpin("camera_distance")

    def OnCameraFovSpin(self, event):
        self.setNumFromSpin("camera_fov")

    def OnPlaneTiltSpin(self, event):
        self.setNumFromSpin("plane_tilt")

    def OnConeHeightSpin(self, event):
        self.setNumFromSpin("cone_height")

    def OnConeRadiusSpin(self, event):
        self.setNumFromSpin("cone_radius")

    def OnExportBitmapWidthSpin(self, event):
        self.setNumFromSpin("export_bitmap_width")
        cw = self.getValue("cone_radius")
        ch = self.getValue("cone_height")
        bmw = self.getValue("export_bitmap_width")
        bmh = (bmw * ch) / cw
        self.setNumVal("export_bitmap_height", bmh)

    def OnExportImageClicked(self, event):
        h = self.getValue("export_bitmap_height")
        w = self.getValue("export_bitmap_width")

        path = self.getValue("export_bitmap") or ""
        d, f = os.path.split(path)
        saveFileDialog = wx.FileDialog(self, "Save Image", d, f,
                                       "PNG files (*.png)|*.png",
                                       wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT)
        self.button_export_image.Enable(False)
        res = saveFileDialog.ShowModal()
        name = saveFileDialog.GetPath()
        saveFileDialog.Destroy()
        if res != wx.ID_CANCEL:
            name = myapp.fixPath(name, ".png")
            self.setValue("export_bitmap", name)

            dlg = wx.ProgressDialog("Working...", "Saving image...",
                                    parent=self, maximum=100,
                                    style=wx.PD_APP_MODAL | wx.PD_SMOOTH |
                                    wx.PD_AUTO_HIDE)

            def updater(pcent):
                dlg.Update(pcent)

            exp = exporters.ImageExporter(self.renderer.renderImage, w, h,
                                          updater)
            exp.generate()
            exp.save(name)

            updater(100)
            dlg.Destroy()

        self.button_export_image.Enable(True)
        return

    def OnExportPdfClicked(self, event):
        w, h, w_mm, h_mm = self.makePageParams()

        path = self.getValue("export_pdf") or ""
        d, f = os.path.split(path)
        saveFileDialog = wx.FileDialog(self, "Save PDF", d, f,
                                       "PDF files (*.pdf)|*.pdf",
                                       wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT)
        self.button_export_pdf.Enable(False)
        res = saveFileDialog.ShowModal()
        name = saveFileDialog.GetPath()
        saveFileDialog.Destroy()
        if res != wx.ID_CANCEL:
            name = myapp.fixPath(name, ".pdf")
            self.setValue("export_pdf", name)

            dlg = wx.ProgressDialog("Working...", "Saving PDF...",
                                    parent=self,
                                    style=wx.PD_APP_MODAL | wx.PD_SMOOTH |
                                    wx.PD_AUTO_HIDE)

            def updater(pcent):
                dlg.Update(pcent)

            exp = exporters.PdfExporter(self.renderer.renderImage,
                                        w, h, w_mm, h_mm, updater)
            exp.generate()
            exp.save(name)

            updater(100)
            dlg.Destroy()

        self.button_export_pdf.Enable(True)
        return


    def OnMenuAbout(self, event):
        info = wx.AboutDialogInfo()

        description = _("""\
ConeDevelopment is an interactive program to explore the development
of a truncated cone.

Truncating a cone by a plane results in second degree curves in the
truncation plane. But what about the curve when you develop the
surface of the truncated cone?

Surprisingly these curves are not so obvious or trivial.

This program lets you explore the question by computing the curve
numerically. One can modify the cone shape and plane angle as desired
and see the resulting development curve.

This program was based on another more complex program,
https://github.com/pbauermeister/Anamorphy. That is why (1) in the
source code there may be remains of the original program, and (2) it
is still in Python 2.x.

I would be interested in any analytical solution (as opposed to the
very overkill numerical solution proposed here). You can kindly
contact me (or post a github ticket) for any hint.

This program was inspired by an interesting discussion with Mr. Udo
Bund, my wife's uncle. It was about the construction of a cap to fit
on the nozzle of a high-pressure Kaercher cleaner in order to reduce
the peripheral projections.
""").replace('\n\n', '@@@').replace('\n', ' ').replace('@@@', '\n\n')

        licence = _("""\
ConeDevelopment is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2 of the License, or (at your
option) any later version.

ConeDevelopment is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details. You should have received a
copy of the GNU General Public License along with ConeDevelopment; if not,
write to the Free Software Foundation, Inc., 59 Temple Place, Suite
330, Boston, MA 02111-1307 USA""")

        info.SetIcon(wx.Icon('logo64.png', wx.BITMAP_TYPE_PNG))
        info.SetName('ConeDevelopment')
        info.SetVersion(version.getVersion())
        info.SetDescription(description)
        info.SetCopyright(_('(C) Copyright 2018 by Pascal Bauermeister'))
        info.SetWebSite('https://github.com/pbauermeister/ConeDevelopment')
        info.SetLicence(licence)
        info.AddDeveloper('Pascal Bauermeister')
        info.AddDocWriter('Pascal Bauermeister')
        #info.AddArtist('Pascal Bauermeister')
        #info.AddTranslator('Pascal Bauermeister')
        wx.AboutBox(info)

    def OnMenuHelp(self, event):
        if sys.platform.startswith('darwin'):
            subprocess.call(('open', 'README.html'))
        elif os.name == 'nt':
            os.startfile('README.html')
        elif os.name == 'posix':
            subprocess.call(('xdg-open', 'README.html'))

    def OnMenuNew(self, event):
        self.endEdits()
        self.new()

    def OnMenuOpen(self, event):
        self.endEdits()
        if not self.saveIfNeeded(_("Save project before opening one?")):
            return

        path = self._config.last_saved
        if path is not None:
            d, f = os.path.split(path)
        else:
            d, f = "", ""

        openFileDialog = wx.FileDialog(self, "Open Project", d, f,
                                       "*" + constants.EXTENSION,
                                       wx.FD_OPEN | wx.FD_FILE_MUST_EXIST)
        if openFileDialog.ShowModal() != wx.ID_CANCEL:
            filename = openFileDialog.GetPath()
            self.loadFile(filename)
        openFileDialog.Destroy()

    def OnMenuPrint(self, event):
        self.endEdits()
        self.printProject()

    def OnMenuQuit(self, event):
        self.endEdits()
        self.OnCloseFrame(event)

    def OnMenuRedo(self, event):
        self.endEdits()
        if self.undo.canRedo():
            res = self.undo.redo()
            if res is not None:
                self.dirty, self.values = res
                self.refreshControls()
                self.updateState()

    def OnMenuUndo(self, event):
        self.endEdits()
        if self.undo.canUndo():
            res = self.undo.undo()
            if res is not None:
                self.dirty, self.values = res
                self.refreshControls()
                self.updateState()

    def OnMenuSave(self, event):
        self.endEdits()
        self.save()

    def OnMenuSaveAs(self, event):
        self.endEdits()
        self.saveAs()

    def OnShowFullscreenClicked(self, event):
        self.endEdits()
        self.renderer.renderScreen(self)
